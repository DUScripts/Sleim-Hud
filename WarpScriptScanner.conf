# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: SleimWarpScan

slots:
    core:
        class: CoreUnit
    warpdrive:
        class: WarpDriveUnit
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    radar:
        class: RadarPVPUnit
        select: manual
    screen:
        class: ScreenUnit
        select: manual

handlers:
    unit:
        start:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 1
                unit.hide()
                newRadarContacts = {}
                printSZContacts = false --export:
                printLocationOnContact = true --export:
                showTime = true --export:
                screenHtml = "<style>html{background-color:#36393E;}</style><h1>Scanning:</h1>"
                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(4)


                isBraking = true
                system.showHelper(0)
                if screen_1 ~= nil then
                    screen_1.setHTML(screenHtml)
                end
                function getFriendlyDetails(id)
                    owner = radar.getConstructOwner(id)
                    if owner.organizationId > 0 then
                        return system.getOrganizationName(owner.organizationId)
                    end
                    if owner.playerId > 0 then
                        return system.getPlayerName(owner.playerId)
                    end
                    return ""
                end
                function brakeTroogle()
                    if isBraking then
                        isBraking = false
                        brakeInput = 0
                    else
                        isBraking = true
                        brakeInput = brakeInput + 1
                        local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                        if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                            local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                            if (math.abs(targetSpeed) > constants.epsilon) then
                                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                            end
                        end
                    end
                end

                
                atlas = require('atlas')

                function round(num, numDecimalPlaces)
                  local mult = 10^(numDecimalPlaces or 0)
                  return math.floor(num * mult + 0.5) / mult
                end


                function getDistanceDisplayString(distance) 
                    local su = distance > 100000       
                    if su then
                        -- Convert to SU
                        return round(distance / 1000 / 200, 2).."SU"
                    elseif distance < 1000 then
                        return round(distance, 2).."M"
                    else
                        -- Convert to KM
                        return round(distance / 1000, 2).."KM"
                    end
                end
                
                planetList = {}
                for k,nextPlanet in pairs(atlas[0]) do
                    if nextPlanet.type[1]=="Planet" then
                        planetList[#planetList+1]=nextPlanet
                        --system.print(nextPlanet.name[1])
                    end
                end

                function newGetClosestPipe(wp)
                    local pipeDistance
                    nearestDistance = nil
                    local nearestPipePlanet = nil
                    local pipeOriginPlanet = nil

                    for i=1,#planetList,1 do
                        for k=#planetList,i+1,-1 do
                            originPlanet = planetList[i]
                            nextPlanet = planetList[k]
                            local distance = getPipeDistance(vec3(originPlanet.center), vec3(nextPlanet.center),wp)
                            if (nearestDistance == nil or distance < nearestDistance) then
                                nearestPipePlanet = nextPlanet
                                nearestDistance = distance
                                pipeOriginPlanet = originPlanet
                            end
                            --system.print(planetList[i].name[1].."-"..planetList[k].name[1])
                        end
                    end
                    pipeDistance = getDistanceDisplayString(nearestDistance)
                    return pipeOriginPlanet.name[1],nearestPipePlanet.name[1],pipeDistance
                end


                function getCurrentBody(withMoons)
                    local coordinates = core.getConstructWorldPos()
                    local minDistance2, body
                    local coord = vec3(coordinates)
                    for i, v in pairs(atlas[0]) do
                        local distance2 = (vec3(v.center) - coord):len2()
                        if (withMoons or v.type[1]=="Planet") and (not body or distance2 < minDistance2) then -- Never return space.  
                            body = v
                            minDistance2 = distance2
                        end
                    end
                    return body
                end


                function safeZone(WorldPos)
                    local safeWorldPos = vec3({13771471,7435803,-128971})
                    local safeRadius = 18000000
                    local szradius = 500000
                    local currentBody = getCurrentBody(true)
                    local distsz, distp = math.huge
                     local mabs = math.abs
                    local szsafe 
                    distsz = vec3(WorldPos):dist(safeWorldPos)
                    if distsz < safeRadius then
                        return true, mabs(distsz - safeRadius)
                    end
                    distp = vec3(WorldPos):dist(vec3(currentBody.center))
                    if distp < szradius then szsafe = true else szsafe = false end
                    if mabs(distp - szradius) < mabs(distsz - safeRadius) then 
                        return szsafe, mabs(distp - szradius)
                    else
                        return szsafe, mabs(distsz - safeRadius)
                    end
                end

                

                

                function getPipeDistance(origCenter, destCenter,pos) 
                    local pipeDistance
                    local worldPos = vec3(pos)
                    local pipe = (destCenter - origCenter):normalize()
                    local r = (worldPos -origCenter):dot(pipe) / pipe:dot(pipe)

                    if r <= 0. then
                        pipeDistance = (worldPos-origCenter):len()
                                return pipeDistance
                    elseif r >= (destCenter - origCenter):len() then
                        pipeDistance =(worldPos-destCenter):len()
                               return pipeDistance
                    else
                        local L = origCenter + (r * pipe)
                        pipeDistance =  (L - worldPos):len()
                        return pipeDistance
                    end        
                end

                function updatePipeInfo()
                    currentPos = core.getConstructWorldPos()
                    local notPvPZone, pvpDist = safeZone(currentPos)
                    local o,p,d = newGetClosestPipe(currentPos)
                    return o,p,d,notPvPZone,pvpDist
                end
                function drawPipeInfo()
                                    local zone = ""
                                    local originPlanet,pipePlanet,pipeDist,notPvPZone,pvpDist=updatePipeInfo()
                                    if notPvPZone then
                                        zone = "PvP"
                                    else
                                        zone = "Safe"
                                    end
                                    pvpDist = getDistanceDisplayString(pvpDist)
                                    pipeInfoHtml = [[
                                    <style>
                                        .pipeInfo{
                                            position: fixed;
                                            top: 10px;
                                            left: 50%;
                                            transform: translateX(-50%);
                                            text-align: center;
                                            margin-bottom: 20px;
                                        }
                                    </style>
                                    <div class="pipeInfo">
                                        <h1>]]..originPlanet.." - "..pipePlanet..[[: ]]..pipeDist..[[</h1>
                                        <h2>]]..zone..[[ Zone in: ]]..pvpDist..[[<h2>
                                    </div>
                                    ]]
                                end

                function alarmBorder()
                    local alarm = [[
                   <style>
                   .blood {
                    width:100%;
                    height:100%;
                    box-shadow: 0 0 0px 0px red inset;
                    animation:blinking 0.3s 1;
                }

                                    @keyframes blinking{
                                    0%{   box-shadow: 0 0 0px 0px red inset;  }
                                    100%{  box-shadow: 0 0 200px 10px red inset;   }
                                    }
                }
                </style>
                <html class="blood"></html>]]
                system.setScreen(alarm)
                end
                function drawFuelInfo()
                    local fuelCSS=[[<style>
                    .fuelInfo {
                        position: fixed;
                        bottom: 40px;
                        left: 28%;
                        witdh: 200px;
                    }
                    .fuel-bar {
                        text-align: center;
                        background: #142027;
                        color: white;
                        font-family: "Lucida" Grande, sans-serif;
                        font-size: 10px;
                        border-radius: 5vh;
                        border: 1px solid;
                        border-color: #098dfe;
                    }
                    .barFullness {
                        padding: 5px;
                        border-radius: 5vh;
                        height: 95%;
                        position: center;
                        text-align: left;
                    }
                    </style>]]

                    function addFuelTank(tank,i)
                        local color = "green"
                        local percent = json.decode(tank.getData()).percentage
                         if percent == nil then 
                                            percent = 0 
                                            color = "red"
                                        elseif percent < 15 then
                                            color = "red" 
                                        elseif percent < 50 then
                                            color = "orange"
                                        end
                        return [[
                       <tr><td style="width:200px"><div class="fuel-bar">
                            <div class="barFullness" style="width: ]]..percent..[[%;
                        background:]]..color..[[;">]]..percent..[[%</div>
                        </div></td></tr>
                    ]]
                    end
                    
                    fuelHtml = fuelCSS..[[<table class="fuelInfo">
                        ]]
                    if spacefueltank_size > 0 then
                            fuelHtml = fuelHtml..[[<tr>
                            <th>Space</th>
                        </tr>]]
                    end
                    for i=1,#spacefueltank do
                        
                        fuelHtml = fuelHtml..addFuelTank(spacefueltank[i],i)
                    end
                    if atmofueltank_size > 0 then
                            fuelHtml = fuelHtml..[[<tr>
                            <th>Atmo</th>
                        </tr>]]
                    end
                    
                    for i=1,#atmofueltank do
                        fuelHtml = fuelHtml..addFuelTank(atmofueltank[i],i)
                    end
                    fuelHtml = fuelHtml.."</table></div>"
                end

                function brakeHud()
                    if isBraking then
                    brakeHtml = [[
                        <style>
                        .brake{
                            position: fixed;
                            left: 50%;
                            bottom: 25%;
                            transform: translateX(-50%); 
                            text-align: center;
                            color: red;
                            text-shadow: 2px 2px 2px black;
                        }
                        </style>
                        <h1><div class="brake">Brake Engaged</div></h1>
                    ]]
                    else
                        brakeHtml = ""
                    end
                end
                function speedInfo()
                                    local throttle = math.floor(unit.getThrottle())
                                    local speed = math.floor(vec3(core.getWorldVelocity()):len() * 3.6)
                                    local accel = math.floor((json.decode(unit.getData()).acceleration/9.80665)*10)/10

                                    local c = 8333.33
                                    local m0 = core.getConstructMass()
                                    local v0 = vec3(core.getWorldVelocity())
                                    local controllerData = json.decode(unit.getData())
                                    local maxBrakeThrust = controllerData.maxBrake
                                    local time = 0.0
                                    dis = 0.0
                                    local v = v0:len()
                                    while v>1.0 do
                                      time = time + 1
                                      local m = m0 / (math.sqrt(1 - (v * v) / (c * c)))
                                      local a = maxBrakeThrust / m
                                      if v > a then
                                        v = v - a --*1 sec
                                        dis = dis + v + a / 2.0
                                      elseif a ~= 0 then
                                        local t = v/a
                                        dis = dis + v * t + a*t*t/2
                                        v = v - a
                                      end
                                    end
                                    local resString = ""
                                    if dis > 100000 then
                                      resString = resString..string.format(math.floor((dis/200000) * 10)/10)
                                      brakeText = "SU"  
                                    elseif dis > 1000 then
                                      resString = resString..string.format(math.floor((dis/1000)*10)/10)
                                      brakeText = "KM"  
                                    else
                                      resString = resString..string.format(math.floor(dis))
                                      brakeText = "M"  
                                    end

                                    speedHtml = [[
                                        <style>
                                            h1{
                                            color: #80ffff;
                                            }
                                        table.speed{
                                            position: fixed;
                                            table-layout: fixed;
                                            left: 60%;
                                            bottom: 35%;
                                            border-spacing: 0 10px;
                                            border-collapse: separate;
                                            }
                                        table.speed td{
                                            width: 33%;
                                        }          
                                        </style>
                                            <table class="speed">
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..throttle..[[</h1></td>
                                                    <td>%</td>
                                                </tr>
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..speed..[[</h1></td>
                                                    <td>km/h</td>
                                                </tr>
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..accel..[[</h1></td>
                                                    <td>g</td>
                                                </tr>
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..resString..[[</h1></td>
                                                    <td>]]..brakeText..[[ Brake-Dist</td>
                                                </tr>
                                            </table>

                                    ]]
                                end
                
                

                function seconds_to_clock(time_amount)
                    local start_seconds = time_amount
                    local start_minutes = math.modf(start_seconds/60)
                    local seconds = start_seconds - start_minutes*60
                    local start_hours = math.modf(start_minutes/60)
                    local minutes = start_minutes - start_hours*60
                    local start_days = math.modf(start_hours/24)
                    local hours = start_hours - start_days*24
                    if hours > 0 then
                    local wrapped_time = {h=hours, m=minutes, s=seconds}
                    return string.format('%02.f:%02.f:%02.f', wrapped_time.h, wrapped_time.m, wrapped_time.s)
                    else
                        local wrapped_time = {m=minutes, s=seconds}
                        return string.format('%02.f:%02.f', wrapped_time.m, wrapped_time.s)
                    end
                end

                function printNewRadarContacts()
                    if radar_size > 1 then
                        if radar_1.isOperational()==0 then
                            radar_1.hide()
                            radar_2.show()
                            radar = radar_2
                        else
                            radar_2.hide()
                            radar_1.show()
                            radar = radar_1
                        end
                    end
                    local originPlanet,pipePlanet,pipeDist,notPvPZone,pvpDist=updatePipeInfo()
                    local d = pvpDist
                    pvpDist = getDistanceDisplayString(pvpDist)
                    if (not notPvPZone or printSZContacts) and d > 3*200000 then
                        local newTargetCounter = 0
                        for k,v in pairs(newRadarContacts) do
                            if newTargetCounter > 10 then
                                system.print("Didnt print all new Contacts to prevent overload!")
                            break end
                            newTargetCounter = newTargetCounter + 1
                            newTargetName = "["..radar.getConstructCoreSize(v).."]- "..radar.getConstructName(v)
                            if showTime then
                                newTargetName = newTargetName..' - Time: '..seconds_to_clock(system.getTime())
                            end
                            if radar.hasMatchingTransponder(v) == 1 then
                                newTargetName = newTargetName.." - [Ally] Owner: "..getFriendlyDetails(v)
                            elseif radar.isConstructAbandoned(v) == 1 then
                                newTargetName = newTargetName.." - Abandoned"
                            else
                                system.playSound("contact.mp3")
                            end
                            
                            system.print("New Target: "..newTargetName)
                            if printLocationOnContact then
                                system.print(originPlanet.." - "..pipePlanet.." | PvP-Border in "..pvpDist.." to "..getCurrentBody().name[1])
                                system.print(system.getWaypointFromPlayerPos())
                            end
                            if screen_1 ~= nil then
                                screenHtml = screenHtml..[[
                                <div><h2>]]..newTargetName..[[</h2>
                                </div><br>
                                <div><h4>]]..originPlanet.." - "..pipePlanet.." PvP-Border in "..pvpDist..[[</h4></div><br>
                                <div style="color:orange">]]..system.getWaypointFromPlayerPos()..[[</div><br>]]
                                screen_1.setHTML(screenHtml)
                            end
                        end
                        newRadarContacts = {}
                    else
                        newRadarContacts = {}
                    end
                end
                
                function combineHudElements()
                    drawFuelInfo()
                    brakeHud()
                    speedInfo()
                    drawPipeInfo()
                    system.setScreen(fuelHtml..brakeHtml..speedHtml..pipeInfoHtml)
                end
                unit.setTimer("hud",0.1)
                unit.setTimer("radar",0.4)
                system.showScreen(1)
                if warpdrive ~=nil then warpdrive.show() end
                if radar_size == 1 then
                    radar = radar_1
                    radar.show()
                end

                
        tick:
            args: ["hud"]
            lua: |
                combineHudElements()
        tick:
            args: ["radar"]
            lua: |
                printNewRadarContacts()
    radar_1:
        enter(id):
            lua: |
                newRadarContacts[#newRadarContacts+1] = id

    radar_2:
        enter(id):
            lua: |
                newRadarContacts[#newRadarContacts+1] = id         
        
    system:
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: Nav:update()

       
        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                brakeTroogle()
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: |
                --brakeInput = brakeInput - 1

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end